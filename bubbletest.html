<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script type="module" src="./js/module/makebubble.js" defer></script>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #root {
      width: 100vw;
      height: 100vh;
    }

    #water-bg {
      width: inherit;
      height: inherit;
      background-color: #3773a5;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="root">
    <section id="water-bg"></section>
  </div>
  <script>
    const root = document.getElementById('root');
    console.log(root);
    const waterBg = document.getElementById('water-bg');
    console.log(waterBg);

    // todo: 배경이 고정된 채로 인트로 페이지를 제외한 나머지 페이지에서 보여주려면...? => fixed로 바꿔주면 될 것 같고

    // todo: 1. 우선 인트로 페이지가 끝나고나서 생성되어야 함 => 해결 인트로에서 모든 인터랙션이 종료된 후에 생성되도록 했다 -> 주석 처리해 둠
    // todo: 2. 물방울이 생기도록 요소가 랜덤의 숫자로  반복해서 생겨나도록 해야한다 -> waterBg가 인트로 페이지 이후에 로드 될 때

    // *랜덤의 숫자가 리턴되도록 해주는 함수
    const randomNum = (min = 0, max) => {
      // ?Math.floor(): 주어진 숫자와 같거나 작은 정수 중에서 가장 큰 수를 반환한다
      return Math.floor(Math.random() * (max - min) + min);
    }
    // *랜덤 숫자만큼 요소를 만들어 주는 함수
    function makeBubble(number, elem, contents = '') {
      let string = '';
      for (let i = 0; i < number; i++) {
        string += `<${elem}>${contents}</${elem}>`
      }
      return string;
    }
    // *bubble 사이즈를 정해주는 함수
    function setBubble(elem, width, height, radius = '100%'){
      elem.setAttribute('style',`width: ${width}; height: ${height}; border-radius: ${radius};`);
    }
    // ?물 배경이 로드 될 때마다
    waterBg.addEventListener('wheel', () => {
      // ?물방울이 생기도록 요소가 랜덤의 숫자로 반복해서 자식요소로 덧붙여지도록 해준다
      // ?요소마다 크기를 정해주고
      // ?짝수는 stroke, 홀수는 fill로 채워준다
      // ?그리고 요소마다 간격을 두로 animate()로 움직임을 부여해준다
      console.log('mouseover');
      // randomNum(1, 6);
      console.log(randomNum(1, 50)); // 랜덤으로 잘 나온다

      
      waterBg.style.display = 'flex';
      waterBg.style.justifyContent = 'space-around';
      waterBg.style.alignItems = 'flex-end';
      // waterBg.style.columnGap = `${randomNum(1, 10)}`;
      
      // *bubble 요소를 랜덤 숫자만큼 덧붙여 줄 부분 => 랜덤 숫자만큼 만들어지면 너무 많아져서, 하나씩 만들어 준다
      waterBg.innerHTML += `${makeBubble(2, 'div', '')}`;
      const bubbleMoving = [
        {transform: `translate(0, 0)`},
        {transform: `translate(${-randomNum(1, 100)}vw, ${-randomNum(1, 100)}vh)`},
        {transform: `translate(${-randomNum(1, 100)}vw, ${-randomNum(1, 100)}vh)`}
      ]
      const bubbleMovingReverse = [
        {transform: `translate(0, 0)`},
        {transform: `translate(${-randomNum(1, 100)}vw, ${randomNum(1, 100)}vh)`},
        {transform: `translate(${randomNum(1, 100)}vw, ${randomNum(1, 100)}vh)`}
      ]
      const bubbleMovingHorizonal = [
        {transform: `translate(0, 0)`},
        {transform: `translate(${-randomNum(1, 100)+10}vw, ${randomNum(1, 100)+10}vh)`},
        {transform: `translate(${-randomNum(1, 100)+10}vw, ${randomNum(1, 100)}vh)`}
      ]
      const bubbleTiming = {
        duration: 20000,
        fill: 'forwards',
        iterations: Infinity
      }


      // *bubble 식별
      const bubbleItem = Array.from(waterBg.children);
      console.log(bubbleItem);  
      bubbleItem.map(elem => {
        // *크기 무작위로 만들어내기
        // ?크기가 자꾸 틀어진다, 가로 세로 값이 똑같아야 타원이 아닌 원이 나올 것
        // 각각이 아니라 변수에 랜덤 숫자를 담아서 사용해줘야 둘 다 같은 수를 적용해 사이즈가 타원이 되지 않음
        let bubbleSize = `${randomNum(5, 20)}`;
        setBubble(elem, `${bubbleSize}px`, `${bubbleSize}px`, '100%');
        elem.style.backgroundColor = '#bad8f2';
        // elem.animate();
        elem.style.position = 'relative';
      });
      bubbleItem.forEach((elem, index) => {
        // ?위치가 한꺼번에 움직이기도 하고 너무 
        if(index%5 === 0){
          elem.style.bottom = '10vh';
          elem.animate(bubbleMoving, bubbleTiming);
        } else if(index%3 === 0){
          elem.style.bottom = '20vh';
          elem.animate(bubbleMovingReverse, bubbleTiming);
          elem.style.opacity = 0.5;
        } else{
          elem.style.bottom = '30vh';
          elem.animate(bubbleMovingHorizonal, bubbleTiming);
          elem.style.opacity = 0.2;
          elem.style.border = '1px solid #fff';
        }
      });
      
    })
  </script>
</body>

</html>